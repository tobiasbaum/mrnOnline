<!DOCTYPE html>
<html>
<head>
<title>MRN Online</title>
<script
  src="https://code.jquery.com/jquery-3.4.1.min.js"
  integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
  crossorigin="anonymous"></script>
<script src="https://unpkg.com/peerjs@1.0.0/dist/peerjs.min.js"></script>
<script src="./decks.php"></script>
<script>

class CardType {
  constructor(name, img) {
    this.name = name;
    this.img = img;
  }

  toDto() {
    return {
      name: this.name,
      img: this.img
    };
  }
}

function cardTypeFromDto(dto) {
  return new CardType(dto.name, dto.img);
}

class Action {
  constructor(text, func) {
    this.text = text;
    this.func = func;
  }
}

var cardCnt = 0;

class Card {

  constructor(type, id, tapped) {
    this.type = type;
    if (typeof id === 'undefined') {
      this.id = Math.floor(Math.random() * 10000) * 1000 + cardCnt++;
    } else {
      this.id = id;
    }
    if (typeof tapped === 'undefined') {
      this.tapped = false;
    } else {
      this.tapped = tapped;
    }
  }

  tap() {
    this.tapped = true;
  }

  untap() {
    this.tapped = false;
  }

  get name() {
    return this.type.name;
  }

  format() {
    let t = this.tapped ? ' tapped' : '';
    let f;
    if (this.type.img) {
      f = '<img class="card" src="' + this.type.img + '" />';
    } else {
      f = this.name;
    }
    return '<table class="card' + t + '"><tr><td>' + f + '</td></tr></table>';
  }

  getActions(currentPosition) {
    if (currentPosition === 'accessDenied') {
      return [];
    }
    let ret = [];
    if (currentPosition === 'table') {
      if (this.tapped) {
        ret.push(new Action('Enttappen', 'untap(' + this.id + ')'));
      } else {
        ret.push(new Action('Tappen', 'tap(' + this.id + ')'));
      }
    } else {
        ret.push(new Action('ins Spiel bringen', 'putIntoPlay(' + this.id + ')'));
        ret.push(new Action('getappt ins Spiel bringen', 'putIntoPlayTapped(' + this.id + ')'));
    }
    if (currentPosition !== 'graveyard') {
      ret.push(new Action('auf Friedhof legen', 'putToGraveyard(' + this.id + ')'));
    }
    return ret;
  }

  toDto() {
    return {
      id: this.id,
      type: this.type.toDto(),
      tapped: this.tapped
    }
  }
}

function cardFromDto(dto) {
  return new Card(cardTypeFromDto(dto.type), dto.id, dto.tapped);
}

class CardCollection {
  constructor(cards) {
    this.cards = cards;
  }

  add(card) {
    this.cards.push(card);
  }

  contains(cardId) {
    for (let i = 0; i < this.cards.length; i++) {
      if (this.cards[i].id === cardId) {
        return true;
      }
    }
    return false;
  }

  getById(cardId) {
    for (let i = 0; i < this.cards.length; i++) {
      if (this.cards[i].id === cardId) {
        return this.cards[i];
      }
    }
    return null;
  }

  remove(cardId) {
    for (let i = 0; i < this.cards.length; i++) {
      if (this.cards[i].id === cardId) {
        let card = this.cards[i];
        this.cards.splice(i, 1);
        return card;
      }
    }
    return null;
  }

  get size() {
    return this.cards.length;
  }

  formatAll(currentPosition) {
    let ret = '';
    this.cards.forEach(function (x) {
      ret += withDropdown(x.format(), x.getActions(currentPosition));
    });
    return ret;
  }

  toDto() {
    return this.cards.map(x => x.toDto());
  }
}

function withDropdown(content, actions) {
  let ret = '<div class="dropdown">' + content + '<div class="dropdown-content">';
  for (let i = 0; i < actions.length; i++) {
    ret += '<a href="javascript:' + actions[i].func + '">' + actions[i].text + '</a>';
  }
  ret += '</div></div>';
  return ret;
}

class CardStash extends CardCollection {
  constructor(cards) {
    super(cards);
  }

  shuffle() {
    var currentIndex = this.cards.length;
    var temporaryValue;
    var randomIndex;

    // While there remain elements to shuffle...
    while (0 !== currentIndex) {

      // Pick a remaining element...
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex -= 1;

      // And swap it with the current element.
      temporaryValue = this.cards[currentIndex];
      this.cards[currentIndex] = this.cards[randomIndex];
      this.cards[randomIndex] = temporaryValue;
    }
  }

  draw() {
    return this.cards.shift();
  }
}

class CardBag extends CardCollection {
  constructor(cards) {
    super(cards);
  }
}

class SelfPlayer {
  constructor(id, name, deck, db) {
    this.id = id;
    this.name = name;
    this.db = db;
    this.library = new CardStash(deck);
    this.library.shuffle();
    this.hand = new CardBag([]);
    this.table = new CardBag([]);
    this.graveyard = new CardStash([]);
    this.db.put('graveyards', this.id, this.graveyard.toDto());
    this.lifes = 20;
    this.db.put('lifes', this.id, this.lifes);
    this.color = 'hsl(' + (Math.floor(Math.random() * 72) * 5) + ',90%,40%)';
  }

  format() {
    let ret = '<div>Hand<br/>';
    ret += this.hand.formatAll('hand');
    ret += '</div>';
    ret += '<div>Ausgelegt:<br/>';
    ret += this.table.formatAll('table');
    ret += '</div>';
    ret += '<div>Bibliothek: ' + this.library.size + ' Karten. <a href="javascript:drawCard()">Karte ziehen</a></div>';
    ret += '<div>Friedhof:<br/>';
    ret += this.graveyard.formatAll('graveyard');
    ret += '</div>';
    ret += '<div>Lebenspunkte: ' + this.lifes + ' <a href="javascript:increaseLifes()">+</a> <a href="javascript:decreaseLifes()">-</a></div>';
    return ret;
  }

  makeColored(msg) {
    return '<span style="color:' + this.color + '">' + msg + '</span>';
  }

  drawCard() {
    this.hand.add(this.library.draw());
    this.sendNotification(this.name + ' zieht eine Karte');
  }

  changeLifeCount(diff) {
    this.lifes += diff;
    this.db.put('lifes', this.id, this.lifes);
    if (diff > 0) {
      this.sendNotification(this.name + ' erhöht Lebenspunkte um ' + diff + ' auf ' + this.lifes);
    } else {
      this.sendNotification(this.name + ' verringert Lebenspunkte um ' + -diff + ' auf ' + this.lifes);
    }
  }

  putToGraveyard(cardId) {
    let coll = this.getContainingCollection(cardId);
    let card = this.removeFromCollection(coll, cardId);
    card.untap();
    this.graveyard.add(card);
    this.db.put('graveyards', this.id, this.graveyard.toDto());
    this.sendNotification(this.name + ' legt ' + card.name + ' auf Friedhof');
  }

  putIntoPlay(cardId) {
    let coll = this.getContainingCollection(cardId);
    let card = this.removeFromCollection(coll, cardId);
    this.addToTable(card);
    this.sendNotification(this.name + ' spielt ' + card.name + ' aus');
  }

  putIntoPlayTapped(cardId) {
    let collData = this.getContainingCollection(cardId);
    let card = this.removeFromCollection(collData, cardId);
    card.tap();
    this.addToTable(card);
    this.sendNotification(this.name + ' spielt ' + card.name + ' getappt aus');
  }

  removeFromCollection(collData, cardId) {
    let card = collData.obj.remove(cardId);
    if (collData.countOnly) {
      this.db.put(collData.name, this.id, collData.obj.size);
    } else {
      this.db.put(collData.name, this.id, collData.obj.toDto());
    }
    return card;
  }

  addToTable(card) {
    this.table.add(card);
    this.db.put('tables', this.id, this.table.toDto());
  }

  getContainingCollection(cardId) {
    if (this.hand.contains(cardId)) {
      return {obj: this.hand, name: 'handSizes', countOnly: true};
    }
    if (this.table.contains(cardId)) {
      return {obj: this.table, name: 'tables', countOnly: false};
    }
    if (this.graveyard.contains(cardId)) {
      return {obj: this.graveyard, name: 'graveyards', countOnly: false};
    }
    if (this.library.contains(cardId)) {
      return {obj: this.library, name: 'librarySizes', countOnly: true};
    }
  }

  tap(cardId) {
    let card = this.table.getById(cardId);
    card.tap();
    this.db.put('tables', this.id, this.table.toDto());
    this.sendNotification(this.name + ' tappt ' + card.name);
  }

  untap(cardId) {
    let card = this.table.getById(cardId);
    card.untap();
    this.db.put('tables', this.id, this.table.toDto());
    this.sendNotification(this.name + ' enttappt ' + card.name);
  }

  sendNotification(msg) {
    this.db.add('messages', this.makeColored(msg));
  }

}

class OtherPlayer {
  constructor(id, db) {
    this.id = id;
    this.db = db;
  }

  get name() {
    return this.db.get('playerNames', this.id);
  }

  get lifes() {
    return this.db.get('lifes', this.id);
  }

  get graveyard() {
    return this.getCardStash('graveyards');
  }

  get table() {
    return this.getCardStash('tables');
  }

  getCardStash(stashId) {
    let g = this.db.get(stashId, this.id);
    if (!g) {
      g = [];
    }
    return new CardStash(g.map(x => cardFromDto(x)));
  }

}

class Database {

  constructor() {
    this.times = {};
    this.data = {};
  }

  put(time, id, data) {
    if (id in this.times) {
      var lastTime = this.times[id];
      if (lastTime < time) {
        this.times[id] = time;
        this.data[id] = data;
        return 'update';
      } else {
        return 'ignore';
      }
    } else {
      this.times[id] = time;
      this.data[id] = data;
      return 'add';
    }
  }

  get(id) {
    return this.data[id];
  }

  dumpEntries(conn, databaseName, sender, knownReceivers) {
      let _this = this;
    Object.keys(this.times).forEach(function (id) {
      let packet = {
        src: sender,
        t: _this.times[id],
        rcv: knownReceivers,
        db: databaseName,
        id: id,
        dta: _this.data[id]
      };
      conn.send(packet);
      console.log('dump ' + JSON.stringify(packet) + ' to ' + conn.peer);
    });
  }
}

class DistributedDatabaseSystem {

  constructor(peer, ownName) {
    this.peer = peer;
    this.ownName = ownName;
    this.time = 0;
    this.otherNames = [];
    this.others = [];
    this.callbacks = {add: {}, update: {}, ignore: {}};
    this.databases = {};
  }

  connectToNode(id) {
    var conn = this.peer.connect(id, {reliable: true});
    this.addNode(conn);
  }

  addNode(conn) {
    this.otherNames.push(conn.peer);
    this.others.push(conn);
    var _this = this;
    conn.on('data', function(d) {
      _this.handleData(d);
    });
    conn.on('open', function(d) {
      _this.dumpDatabasesTo(conn);
    });
  }

  dumpDatabasesTo(conn) {
    for (let [name, db] of Object.entries(this.databases)) {
      db.dumpEntries(conn, name, this.ownName, this.otherNames);
    }
  }

  handleData(d) {
    console.log('received: ' + JSON.stringify(d));
    this.ensureDbExists(d.db);
    var eventType = this.databases[d.db].put(d.t, d.id, d.dta);
    if (this.callbacks[eventType][d.db]) {
      this.callbacks[eventType][d.db](d.id, d.dta);
    }
    if (eventType != 'ignore') {
      this.forwardToFurtherReceivers(d);
    }
    this.establishConnectionToUnknownNodes(d);
  }

  ensureDbExists(dbName) {
    if (!this.databases[dbName]) {
      this.databases[dbName] = new Database();
    }
  }

  forwardToFurtherReceivers(packet) {
    let furtherReceivers = [];
    let existingSet = new Set(packet.rcv);
    existingSet.add(this.ownName);
    existingSet.add(packet.src);
    this.otherNames.forEach(function (x) {
      if (!existingSet.has(x)) {
        furtherReceivers.push(x);
      }
    });
    packet.rcv.push(...furtherReceivers);
    let _this = this;
    furtherReceivers.forEach(function(id) {
      let index = _this.otherNames.indexOf(id);
      let conn = _this.others[index];
      conn.send(packet)
    });
  }

  establishConnectionToUnknownNodes(packet) {
    let _this = this;
    let nameSet = new Set(this.otherNames);
    nameSet.add(this.ownName);
    packet.rcv.filter(x => !nameSet.has(x)).forEach(function (x) {
      _this.connectToNode(x);
    });
    if (!nameSet.has(packet.src)) {
      this.connectToNode(packet.src);
    }
  }

  add(listDb, data) {
    this.put(listDb, this.ownName + this.time, data);
  }

  put(database, id, data) {
    var packet = {
      src: this.ownName,
      t: this.time++,
      rcv: this.otherNames,
      db: database,
      id: id,
      dta: data
    };
    this.others.forEach(function(x) {
      x.send(packet);
    })
    this.handleData(packet);
  }

  get(database, id) {
    if (!this.databases[database]) {
      return undefined;
    }
    return this.databases[database].get(id);
  }

  on(eventType, database, action) {
    this.callbacks[eventType][database] = action;
  }

}

class GameField {

  constructor(peer, ownId, ownName) {
    this.others = [];
    this.db = new DistributedDatabaseSystem(peer, ownId);
    var _this = this;
    this.db.on('add', 'messages', function(id, msg) {_this.handleAddedMessage(msg)});
    this.db.on('add', 'playerNames', function(id, name) {_this.handleChangedPlayerName(id, name)});
    this.db.on('update', 'playerNames', function(id, name) {_this.handleChangedPlayerName(id, name)});
    this.db.on('update', 'lifes', function(id, cnt) {_this.updatePlayers()});
    this.db.on('update', 'graveyards', function(id, cards) {_this.updatePlayers()});
    this.db.on('update', 'tables', function(id, cards) {_this.updatePlayers()});

    this.myself = new SelfPlayer(ownId, ownName, window.mrnOnline.deck, this.db);
    this.db.put('playerNames', ownId, ownName);
  }

  connectToOtherPlayer(id) {
    this.db.connectToNode(id);
    this.others.push(new OtherPlayer(id, this.db));
    this.updatePlayers();
  }

  addOtherPlayer(conn) {
    this.db.addNode(conn);
    this.others.push(new OtherPlayer(conn.peer, this.db));
    this.updatePlayers();
  }

  handleChangedPlayerName(id, name) {
    this.updatePlayers();
  }

  updatePlayers() {
    this.updateSelf();
    var content = '';
    this.others.forEach(function(x) {
      content += '<div id="' + x.name + '"><h2>' + x.name + ' (' + x.id + ')</h2></div>';
      content += x.lifes + ' Lebenspunkte<br/>';
      content += 'Ausgelegt:<br/>'
      content += x.table.formatAll('accessDenied');
      content += 'Friedhof:<br/>'
      content += x.graveyard.formatAll('accessDenied');
    });
    $('#players').html(content);
  }

  updateSelf() {
    $('#self').html(this.myself.format());
  }

  sendMessage(msg) {
    this.sendMessageRaw(this.myself.makeColored(this.myself.name + ': ') + msg);
  }

  sendMessageRaw(msg) {
    this.db.add('messages', msg);
  }

  handleAddedMessage(msg) {
    $('#messages').append('<div>' + msg + '</div>\n');
  }
}

function createPeer(name) {
     if (window.mrnOnline.gameField) {
         return;
     }
     //var peer = new Peer(null, {host: '192.168.178.30', port: 9000, key: 'peerjs'});
     var peer = new Peer(null, {host: 'localhost', port: 9000, key: 'peerjs', debug: 2});
     peer.on('error', function (err) {
         console.log(err);
         alert('' + err);
     });
     peer.on('open', function(id) {
         //alert('My peer ID is: ' + id);
         $('#inhalt').html('My peer ID is: ' + id);
         window.mrnOnline.gameField = new GameField(peer, id, name);
     });
     peer.on('connection', function(conn) {
         //alert('Got connection ' + conn);
         window.mrnOnline.gameField.addOtherPlayer(conn);
     });
}

function start() {
     mapDecksAndCards();
     var name = prompt('Name');
     if (name) {
       createPeer(name);
     }
}

function mapDecksAndCards() {
  window.mrnOnline.cards = {};
  for (let i = 0; i < window.mrnData.cards.length; i++) {
    let card = window.mrnData.cards[i];
    window.mrnOnline.cards[card.name] = new CardType(card.name, card.img);
  }
  let d = window.mrnData.decks[0].cards;
  window.mrnOnline.deck = [];
  for (let i = 0; i < d.length; i++) {
    let card = d[i];
    window.mrnOnline.deck.push(new Card(window.mrnOnline.cards[card]));
  }
}

function join() {
     var other = prompt('ID des Mitspielers');
     if (other) {
       window.mrnOnline.gameField.connectToOtherPlayer(other);
     }
}

function sendMessage() {
     var message = prompt('Nachricht');
     if (message) {
       window.mrnOnline.gameField.sendMessage(message);
     }
}

function drawCard() {
  window.mrnOnline.gameField.myself.drawCard();
  window.mrnOnline.gameField.updateSelf();
}

function increaseLifes() {
  window.mrnOnline.gameField.myself.changeLifeCount(1);
  window.mrnOnline.gameField.updateSelf();
}

function decreaseLifes() {
  window.mrnOnline.gameField.myself.changeLifeCount(-1);
  window.mrnOnline.gameField.updateSelf();
}

function putToGraveyard(cardId) {
  window.mrnOnline.gameField.myself.putToGraveyard(cardId);
  window.mrnOnline.gameField.updateSelf();
}

function tap(cardId) {
  window.mrnOnline.gameField.myself.tap(cardId);
  window.mrnOnline.gameField.updateSelf();
}

function untap(cardId) {
  window.mrnOnline.gameField.myself.untap(cardId);
  window.mrnOnline.gameField.updateSelf();
}

function putIntoPlay(cardId) {
  window.mrnOnline.gameField.myself.putIntoPlay(cardId);
  window.mrnOnline.gameField.updateSelf();
}

function putIntoPlayTapped(cardId) {
  window.mrnOnline.gameField.myself.putIntoPlayTapped(cardId);
  window.mrnOnline.gameField.updateSelf();
}

window.mrnOnline = {};
window.mrnOnline.cards = {
  respite: new CardType('Respite'),
  fog: new CardType('Fog'),
  verdantForce: new CardType('Verdant Force'),
  terror: new CardType('Terror'),
  forest: new CardType('Forest')
};

window.mrnOnline.deck = [
  new Card(window.mrnOnline.cards['respite']),
  new Card(window.mrnOnline.cards['respite']),
  new Card(window.mrnOnline.cards['respite']),
  new Card(window.mrnOnline.cards['respite']),
  new Card(window.mrnOnline.cards['fog']),
  new Card(window.mrnOnline.cards['fog']),
  new Card(window.mrnOnline.cards['fog']),
  new Card(window.mrnOnline.cards['fog']),
  new Card(window.mrnOnline.cards['verdantForce']),
  new Card(window.mrnOnline.cards['forest']),
  new Card(window.mrnOnline.cards['forest']),
  new Card(window.mrnOnline.cards['forest']),
  new Card(window.mrnOnline.cards['forest'])
];

</script>
<link rel="stylesheet" type="text/css" href="mrnOnline.css" />
</head>
<body>
<button onClick="javascript:start()">Start</button>
<button onClick="javascript:join()">Join</button>
<div id="inhalt"></div>
<h2>Eigener Spieler</h2>
<div id="self">
</div>
<h2>Mitspieler</h2>
<div id="players">
</div>
<h2>Chat</h2>
<div id="messages">
</div>
<button onClick="javascript:sendMessage()">Send message</button>
</body>
</html>